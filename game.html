<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Alchemist's Number Scroll Advanced vs. Bot</title>
    <link rel="icon" type="image/png" href="https://cdn-icons-png.flaticon.com/512/8068/8068091.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray */
            color: #2d3748; /* Dark gray */
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 1rem;
            box-sizing: border-box;
        }
        .game-container {
            background-color: #ffffff;
            border-radius: 1.5rem; /* More rounded */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            max-width: 900px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        .header {
            text-align: center;
            margin-bottom: 1rem;
        }
        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            color: #4a5568;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
        .header p {
            font-size: 1.1rem;
            color: #718096;
        }
        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 0.75rem;
            border-bottom: 2px solid #edf2f7;
            padding-bottom: 0.5rem;
        }
        .card-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            justify-content: center;
            min-height: 5rem; /* Ensure space even when empty */
            align-items: center;
        }
        .number-card {
            background-color: #e2e8f0; /* Light gray */
            border: 2px solid #cbd5e0;
            border-radius: 0.75rem; /* Rounded corners for cards */
            width: 6rem;
            height: 6rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 2.25rem;
            font-weight: 700;
            color: #2c5282; /* Darker blue */
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
            position: relative;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .number-card:hover:not(.selected-card):not(.played-card) {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
            background-color: #d1d9e2;
        }
        .number-card.selected-card {
            border-color: #4299e1; /* Blue for selected */
            box-shadow: 0 0 0 3px #4299e1;
            transform: scale(1.05);
        }
        .number-card.played-card {
            background-color: #a0aec0; /* Gray for played */
            border-color: #718096;
            cursor: default;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
            color: #f7fafc;
        }
        .number-card.prime-type {
            background-color: #c6f6d5; /* Light green for prime */
            border-color: #68d391;
            color: #276749;
        }
        .number-card.composite-type {
            background-color: #fed7d7; /* Light red for composite */
            border-color: #fc8181;
            color: #9b2c2c;
        }
        .number-card.wildcard {
            background-color: #fbd38d; /* Amber for wildcard */
            border-color: #dd6b20;
            color: #9c4221;
            font-size: 1.8rem; /* Smaller font for "WILDCARD" */
            line-height: 1.2;
            padding: 0.5rem;
        }
        .number-card .type-label {
            font-size: 0.75rem;
            font-weight: 600;
            position: absolute;
            bottom: 0.5rem;
            left: 0.5rem;
            right: 0.5rem;
            text-align: center;
            color: #4a5568;
            text-transform: uppercase;
        }
        .scroll-container {
            min-height: 8rem;
            border: 2px dashed #cbd5e0;
            border-radius: 1rem;
            padding: 1rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
            justify-content: center;
            background-color: #f7fafc;
        }
        .scroll-card {
            background-color: #a0aec0;
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            font-size: 1.5rem;
            font-weight: 600;
            color: #f7fafc;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: 4rem;
            min-height: 4rem;
        }
        .scroll-card.prime-type {
            background-color: #68d391;
        }
        .scroll-card.composite-type {
            background-color: #fc8181;
        }
        .scroll-card .type-label {
            font-size: 0.65rem;
            font-weight: 500;
            color: rgba(255,255,255,0.8);
            text-transform: uppercase;
        }
        .button-group {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 1rem;
            flex-wrap: wrap;
        }
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .btn-primary {
            background-color: #4299e1; /* Blue */
            color: white;
        }
        .btn-primary:hover {
            background-color: #3182ce;
            transform: translateY(-2px);
        }
        .btn-secondary {
            background-color: #a0aec0; /* Gray */
            color: white;
        }
        .btn-secondary:hover {
            background-color: #718096;
            transform: translateY(-2px);
        }
        .btn-green {
            background-color: #48bb78; /* Green */
            color: white;
        }
        .btn-green:hover {
            background-color: #38a169;
            transform: translateY(-2px);
        }
        .btn-red {
            background-color: #f56565; /* Red */
            color: white;
        }
        .btn-red:hover {
            background-color: #e53e3e;
            transform: translateY(-2px);
        }
        .btn-purple {
            background-color: #9f7aea; /* Purple */
            color: white;
        }
        .btn-purple:hover {
            background-color: #805ad5;
            transform: translateY(-2px);
        }
        .message-box {
            background-color: #fff;
            border: 2px solid #4299e1;
            border-radius: 0.75rem;
            padding: 1rem;
            margin-top: 1rem;
            font-weight: 600;
            color: #2b6cb0;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .message-box.error {
            border-color: #e53e3e;
            color: #c53030;
        }
        .message-box.success {
            border-color: #38a169;
            color: #276749;
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.3s ease;
        }
        .modal.show {
            visibility: visible;
            opacity: 1;
        }
        .modal-content {
            background-color: #ffffff;
            border-radius: 1rem;
            padding: 2rem;
            max-width: 600px;
            width: 90%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            position: relative;
            max-height: 90vh;
            overflow-y: auto;
        }
        .modal-content h2 {
            font-size: 2rem;
            font-weight: 700;
            color: #4a5568;
            margin-bottom: 1rem;
        }
        .modal-content p {
            font-size: 1rem;
            color: #718096;
            margin-bottom: 1rem;
            line-height: 1.5;
        }
        .modal-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #a0aec0;
        }
        .modal-close-btn:hover {
            color: #718096;
        }

        /* Sieve Styles */
        .sieve-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 2px;
            background-color: #edf2f7;
            border-radius: 0.5rem;
            padding: 0.5rem;
            max-height: 50vh;
            overflow-y: auto;
        }
        .sieve-cell {
            background-color: #ffffff;
            padding: 0.5rem 0.25rem;
            text-align: center;
            font-size: 0.85rem;
            font-weight: 500;
            border-radius: 0.25rem;
            color: #4a5568;
        }
        .sieve-cell.prime {
            background-color: #c6f6d5;
            color: #276749;
            font-weight: 700;
        }
        .sieve-cell.crossed-out {
            text-decoration: line-through;
            color: #a0aec0;
            background-color: #f7fafc;
        }

        /* Wildcard input specific styles */
        .wildcard-input-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 1rem;
            align-items: center;
        }
        .wildcard-input {
            width: 80px;
            padding: 0.5rem;
            border: 2px solid #cbd5e0;
            border-radius: 0.5rem;
            text-align: center;
            font-size: 1.1rem;
        }
        .wildcard-type-select {
            padding: 0.5rem;
            border: 2px solid #cbd5e0;
            border-radius: 0.5rem;
            font-size: 1.1rem;
            background-color: white;
        }
        .wildcard-play-btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            background-color: #805ad5; /* Darker purple */
            color: white;
        }
        .wildcard-play-btn:hover {
            background-color: #6b46c1;
            transform: translateY(-2px);
        }


        @media (max-width: 768px) {
            .game-container {
                padding: 1rem;
                gap: 1rem;
            }
            .header h1 {
                font-size: 1.8rem;
            }
            .header p {
                font-size: 0.9rem;
            }
            .section-title {
                font-size: 1.25rem;
            }
            .number-card {
                width: 5rem;
                height: 5rem;
                font-size: 1.8rem;
            }
            .scroll-card {
                font-size: 1.2rem;
                padding: 0.5rem 0.75rem;
                min-width: 3.5rem;
                min-height: 3.5rem;
            }
            .btn {
                padding: 0.6rem 1.2rem;
                font-size: 0.9rem;
            }
            .sieve-cell {
                font-size: 0.75rem;
            }
            .wildcard-input-group {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <h1>The Alchemist's Number Scroll</h1>
            <p class="text-lg">A Prime & Composite Quest (Advanced vs. Bot)</p>
            <div class="flex justify-center items-center gap-8 mt-4">
                <div class="text-xl font-bold text-blue-700">Your Score: <span id="playerScoreDisplay">0</span></div>
                <div class="text-xl font-bold text-red-700">Bot Score: <span id="botScoreDisplay">0</span></div>
            </div>
            <div id="turnDisplay" class="text-2xl font-bold mt-4 text-purple-700"></div>
            <div id="messageBox" class="message-box hidden"></div>
        </div>

        <div class="game-area">
            <h2 class="section-title">Your Hand</h2>
            <div id="playerHand" class="card-grid">
                <!-- Player hand cards will be rendered here -->
            </div>
            <div class="button-group mt-4">
                <button id="drawCardBtn" class="btn btn-primary">Draw New Tile</button>
                <button id="discardBtn" class="btn btn-secondary" disabled>Discard Selected</button>
            </div>

            <h2 class="section-title mt-6">Linking Rule (Your Choice for the Turn)</h2>
            <div class="button-group">
                <button id="ruleProximityBtn" class="btn btn-purple">Proximity (±10)</button>
                <button id="ruleFactorMultipleBtn" class="btn btn-purple">Factor/Multiple</button>
            </div>
            <p id="currentRuleDisplay" class="text-center text-lg font-semibold mt-2 text-gray-700">Current Rule: Proximity (±10)</p>


            <h2 class="section-title mt-6">Declare & Play</h2>
            <div class="flex flex-col sm:flex-row gap-4 justify-center items-center">
                <div class="flex gap-2">
                    <button id="declarePrimeBtn" class="btn btn-green" disabled>Declare Prime</button>
                    <button id="declareCompositeBtn" class="btn btn-red" disabled>Declare Composite</button>
                </div>
                <button id="newGameBtn" class="btn btn-secondary">New Game</button>
            </div>

            <!-- Wildcard Input Section (initially hidden) -->
            <div id="wildcardInputSection" class="wildcard-input-group hidden">
                <p class="text-lg font-semibold text-gray-700">Play Wildcard as:</p>
                <input type="number" id="wildcardValueInput" class="wildcard-input" placeholder="Number" min="2" max="100">
                <select id="wildcardTypeSelect" class="wildcard-type-select">
                    <option value="">Select Type</option>
                    <option value="prime">Prime</option>
                    <option value="composite">Composite</option>
                </select>
                <button id="playWildcardBtn" class="wildcard-play-btn" disabled>Play Wildcard</button>
            </div>


            <h2 class="section-title mt-6">The Scroll</h2>
            <div id="currentScroll" class="scroll-container">
                <p class="text-gray-500 italic">Play numbers here to build your scroll...</p>
            </div>

            <div class="flex justify-center mt-6">
                <button id="toggleSieveBtn" class="btn btn-primary">Toggle Sieve Reference</button>
            </div>
            <div id="sieveModal" class="modal">
                <div class="modal-content">
                    <button class="modal-close-btn" onclick="toggleSieve()">×</button>
                    <h2>Sieve of Eratosthenes</h2>
                    <p class="text-sm text-gray-600 mb-4">Numbers highlighted in green are Prime. Others are Composite.</p>
                    <div id="sieveGrid" class="sieve-grid">
                        <!-- Sieve numbers will be rendered here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Rules Modal -->
    <div id="rulesModal" class="modal show">
        <div class="modal-content">
            <button class="modal-close-btn" onclick="hideRules()">×</button>
            <h2>The Alchemist's Number Scroll: Advanced Rules</h2>
            <p>Your goal is to build the longest and most valuable "scroll" of numbers by correctly identifying them as Prime or Composite and linking them according to ancient alchemical rules.</p>
            <h3 class="text-xl font-semibold mt-4 mb-2 text-gray-700">How to Play:</h3>
            <ul class="list-disc list-inside text-left text-gray-700 space-y-2">
                <li>You play against a bot. Both players start with 5 Number Tiles.</li>
                <li>Each turn:
                    <ol class="list-decimal list-inside ml-4">
                        <li>**Draw a Tile:** Click "Draw New Tile" to add one to your hand.</li>
                        <li>**Choose Linking Rule:** Select either **Proximity (±10)** or **Factor/Multiple**. This rule applies to *both* players for this turn.</li>
                        <li>**Select a Tile:** Click on any tile in your hand to select it.</li>
                        <li>**Declare & Play:** Click "Declare Prime" or "Declare Composite" for your selected tile.
                            <ul class="list-disc list-inside ml-4 text-sm text-gray-600">
                                <li>**Correct:** The tile is played to your scroll. You score points!</li>
                                <li>**Incorrect:** You lose 1 point, and the tile is discarded. Your turn ends.</li>
                            </ul>
                        </li>
                    </ol>
                </li>
                <li>**Chain Link Rules:**
                    <ul class="list-disc list-inside ml-4 text-gray-700">
                        <li>**Alternating Type:** If the last number in your scroll was **Prime**, the next must be **Composite**. If the last was **Composite**, the next must be **Prime**.</li>
                        <li>**Selected Linking Rule:**
                            <ul class="list-disc list-inside ml-4 text-sm text-gray-600">
                                <li>**Proximity (±10):** The new number must be within $\pm 10$ of the last number in your scroll.</li>
                                <li>**Factor/Multiple:** The new number must be a factor or a multiple of the last number in your scroll.</li>
                            </ul>
                        </li>
                        <li>If your scroll is empty, you can play any number.</li>
                    </ul>
                </li>
                <li>**Wildcard Tile:**
                    <ul class="list-disc list-inside ml-4 text-gray-700">
                        <li>A special tile that can be declared as *any* number (2-100) and *any* type (Prime/Composite) you choose.</li>
                        <li>It must still follow the **Alternating Type** and **Selected Linking Rule** based on its declared value.</li>
                        <li>Use the input fields to declare its value and type, then click "Play Wildcard".</li>
                    </ul>
                </li>
                <li>**No Valid Move:** If you cannot make a valid play, click "Discard Selected" to discard a tile (if one is selected). Your turn ends.</li>
            </ul>
            <h3 class="text-xl font-semibold mt-4 mb-2 text-gray-700">Scoring:</h3>
            <ul class="list-disc list-inside text-left text-gray-700 space-y-2">
                <li>Successfully playing a **Prime** number: 2 points</li>
                <li>Successfully playing a **Composite** number: 1 point</li>
                <li>Incorrect Declaration or Broken Rule: -1 point (for the player who makes it)</li>
                <li>Bonus: +3 points for a chain of 5 numbers.</li>
                <li>Bonus: +7 points for a chain of 10 numbers.</li>
            </ul>
            <p class="mt-4">The game ends when the draw pile runs out and neither player can make a valid move. The player with the highest score wins!</p>
            <button class="btn btn-primary mt-6" onclick="hideRules()">Got It!</button>
        </div>
    </div>

    <script>
        // Game State Variables
        let allNumbers = []; // All possible numbers for the deck
        let primeNumbers = new Set(); // Stores all primes for quick lookup
        let deck = []; // Shuffled array of numbers available to draw
        let playerHand = []; // Numbers currently in the player's hand
        let botHand = []; // Numbers currently in the bot's hand
        let currentScroll = []; // Numbers forming the current chain
        let playerScore = 0;
        let botScore = 0;
        let lastNumberType = null; // 'prime' or 'composite'
        let selectedHandCardIndex = -1; // Index of the currently selected card in hand
        const initialHandSize = 5;
        const maxNumberValue = 100; // Numbers from 1 to 100
        const wildcardChance = 0.05; // 5% chance to draw a wildcard
        const WILDCARD_VALUE = -1; // Special value to denote a wildcard tile
        let currentPlayer = 'player'; // 'player' or 'bot'
        const botTurnDelay = 1500; // Milliseconds for bot's "thinking" time
        let currentLinkingRule = 'proximity'; // 'proximity' or 'factor_multiple'

        // DOM Elements
        const playerHandEl = document.getElementById('playerHand');
        const currentScrollEl = document.getElementById('currentScroll');
        const playerScoreDisplayEl = document.getElementById('playerScoreDisplay');
        const botScoreDisplayEl = document.getElementById('botScoreDisplay');
        const turnDisplayEl = document.getElementById('turnDisplay');
        const messageBoxEl = document.getElementById('messageBox');
        const drawCardBtn = document.getElementById('drawCardBtn');
        const discardBtn = document.getElementById('discardBtn');
        const declarePrimeBtn = document.getElementById('declarePrimeBtn');
        const declareCompositeBtn = document.getElementById('declareCompositeBtn');
        const newGameBtn = document.getElementById('newGameBtn');
        const toggleSieveBtn = document.getElementById('toggleSieveBtn');
        const sieveModal = document.getElementById('sieveModal');
        const sieveGridEl = document.getElementById('sieveGrid');
        const rulesModal = document.getElementById('rulesModal');
        const ruleProximityBtn = document.getElementById('ruleProximityBtn');
        const ruleFactorMultipleBtn = document.getElementById('ruleFactorMultipleBtn');
        const currentRuleDisplay = document.getElementById('currentRuleDisplay');
        const wildcardInputSection = document.getElementById('wildcardInputSection');
        const wildcardValueInput = document.getElementById('wildcardValueInput');
        const wildcardTypeSelect = document.getElementById('wildcardTypeSelect');
        const playWildcardBtn = document.getElementById('playWildcardBtn');


        // --- Utility Functions ---

        /**
         * Checks if a number is prime.
         * @param {number} num The number to check.
         * @returns {boolean} True if prime, false otherwise.
         */
        function isNumberPrime(num) {
            if (num <= 1) return false;
            if (num <= 3) return true; // 2 and 3 are prime
            if (num % 2 === 0 || num % 3 === 0) return false; // Divisible by 2 or 3
            for (let i = 5; i * i <= num; i = i + 6) {
                if (num % i === 0 || num % (i + 2) === 0) return false;
            }
            return true;
        }

        /**
         * Generates and stores prime numbers up to maxNumberValue using Sieve of Eratosthenes.
         */
        function generatePrimes() {
            const sieve = Array(maxNumberValue + 1).fill(true);
            sieve[0] = false;
            sieve[1] = false;
            for (let p = 2; p * p <= maxNumberValue; p++) {
                if (sieve[p]) {
                    for (let i = p * p; i <= maxNumberValue; i += p)
                        sieve[i] = false;
                }
            }
            for (let i = 2; i <= maxNumberValue; i++) {
                if (sieve[i]) {
                    primeNumbers.add(i);
                }
            }
        }

        /**
         * Shuffles an array in place.
         * @param {Array} array The array to shuffle.
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        /**
         * Displays a message to the user.
         * @param {string} message The message text.
         * @param {string} type 'success', 'error', or 'info'.
         */
        function showMessage(message, type = 'info') {
            messageBoxEl.textContent = message;
            messageBoxEl.className = `message-box mt-4 ${type}`;
            messageBoxEl.classList.remove('hidden');
            setTimeout(() => {
                messageBoxEl.classList.add('hidden');
            }, 3000); // Message disappears after 3 seconds
        }

        /**
         * Updates the state of action buttons based on current player and selected card.
         */
        function updateButtonStates() {
            const isPlayerTurn = currentPlayer === 'player';
            drawCardBtn.disabled = !isPlayerTurn || deck.length === 0;
            discardBtn.disabled = !isPlayerTurn || selectedHandCardIndex === -1;

            const isWildcardSelected = selectedHandCardIndex !== -1 && playerHand[selectedHandCardIndex] === WILDCARD_VALUE;
            
            // Show/hide wildcard input section
            wildcardInputSection.classList.toggle('hidden', !isWildcardSelected || !isPlayerTurn);
            
            // Enable/disable declare buttons based on regular card selection
            declarePrimeBtn.disabled = !isPlayerTurn || selectedHandCardIndex === -1 || isWildcardSelected;
            declareCompositeBtn.disabled = !isPlayerTurn || selectedHandCardIndex === -1 || isWildcardSelected;

            // Enable/disable wildcard play button
            playWildcardBtn.disabled = !isWildcardSelected || !wildcardValueInput.value || !wildcardTypeSelect.value;

            // Enable/disable rule buttons only on player's turn and if scroll is empty or not
            ruleProximityBtn.disabled = !isPlayerTurn;
            ruleFactorMultipleBtn.disabled = !isPlayerTurn;

            // Highlight active rule button
            ruleProximityBtn.classList.toggle('btn-primary', currentLinkingRule === 'proximity');
            ruleProximityBtn.classList.toggle('btn-purple', currentLinkingRule !== 'proximity');
            ruleFactorMultipleBtn.classList.toggle('btn-primary', currentLinkingRule === 'factor_multiple');
            ruleFactorMultipleBtn.classList.toggle('btn-purple', currentLinkingRule !== 'factor_multiple');
        }

        /**
         * Checks if a given number can be played according to chain rules.
         * @param {number} num The number to check.
         * @param {string} type 'prime' or 'composite'.
         * @param {string} rule The linking rule to use ('proximity' or 'factor_multiple').
         * @returns {boolean} True if valid, false otherwise.
         */
        function isValidChainPlay(num, type, rule) {
            if (currentScroll.length === 0) {
                // If scroll is empty, 1 can't be played as it's neither prime nor composite for chain purposes
                return num !== 1;
            }

            const lastScrollNumber = currentScroll[currentScroll.length - 1].number;
            const lastScrollType = currentScroll[currentScroll.length - 1].type;

            // Rule: Alternating Prime/Composite
            if (type === lastScrollType) {
                return false;
            }

            // Rule: Proximity (within +/- 10)
            if (rule === 'proximity') {
                return Math.abs(num - lastScrollNumber) <= 10;
            }
            // Rule: Factor/Multiple
            else if (rule === 'factor_multiple') {
                return num % lastScrollNumber === 0 || lastScrollNumber % num === 0;
            }
            return false; // Should not happen
        }

        // --- Render Functions ---

        /**
         * Renders the player's hand.
         */
        function renderPlayerHand() {
            playerHandEl.innerHTML = '';
            if (playerHand.length === 0) {
                playerHandEl.innerHTML = '<p class="text-gray-500 italic">Your hand is empty. Draw a new tile!</p>';
            }
            playerHand.forEach((num, index) => {
                const cardEl = document.createElement('div');
                cardEl.classList.add('number-card');
                if (num === WILDCARD_VALUE) {
                    cardEl.classList.add('wildcard');
                    cardEl.innerHTML = 'WILDCARD<br><span style="font-size:0.8em;">(Any Number)</span>';
                } else {
                    cardEl.textContent = num;
                }
                
                if (index === selectedHandCardIndex) {
                    cardEl.classList.add('selected-card');
                }
                cardEl.dataset.index = index;
                cardEl.addEventListener('click', () => selectHandCard(index));
                playerHandEl.appendChild(cardEl);
            });
            updateButtonStates();
        }

        /**
         * Renders the current scroll (chain of numbers).
         */
        function renderCurrentScroll() {
            currentScrollEl.innerHTML = '';
            if (currentScroll.length === 0) {
                currentScrollEl.innerHTML = '<p class="text-gray-500 italic">Play numbers here to build your scroll...</p>';
            }
            currentScroll.forEach(item => {
                const scrollCardEl = document.createElement('div');
                scrollCardEl.classList.add('scroll-card');
                scrollCardEl.textContent = item.number;
                const typeLabel = document.createElement('span');
                typeLabel.classList.add('type-label');
                typeLabel.textContent = item.type;
                scrollCardEl.appendChild(typeLabel);
                if (item.type === 'prime') {
                    scrollCardEl.classList.add('prime-type');
                } else {
                    scrollCardEl.classList.add('composite-type');
                }
                currentScrollEl.appendChild(scrollCardEl);
            });
        }

        /**
         * Updates the score displays.
         */
        function renderScores() {
            playerScoreDisplayEl.textContent = playerScore;
            botScoreDisplayEl.textContent = botScore;
        }

        /**
         * Updates the turn display.
         */
        function renderTurnDisplay() {
            turnDisplayEl.textContent = `It's ${currentPlayer === 'player' ? 'Your' : 'Bot\'s'} Turn!`;
        }

        /**
         * Renders the Sieve of Eratosthenes grid in the modal.
         */
        function renderSieveGrid() {
            sieveGridEl.innerHTML = '';
            for (let i = 1; i <= maxNumberValue; i++) {
                const cell = document.createElement('div');
                cell.classList.add('sieve-cell');
                cell.textContent = i;
                if (primeNumbers.has(i)) {
                    cell.classList.add('prime');
                } else if (i !== 1) { // 1 is neither prime nor composite, but we cross it out
                    cell.classList.add('crossed-out');
                }
                sieveGridEl.appendChild(cell);
            }
        }

        /**
         * Updates the current linking rule display.
         */
        function renderCurrentRuleDisplay() {
            currentRuleDisplay.textContent = `Current Rule: ${currentLinkingRule === 'proximity' ? 'Proximity (±10)' : 'Factor/Multiple'}`;
            updateButtonStates(); // Update button highlights
        }

        // --- Game Logic Functions ---

        /**
         * Initializes or resets the game.
         */
        function initGame() {
            // Reset game state
            allNumbers = Array.from({ length: maxNumberValue }, (_, i) => i + 1);
            deck = [...allNumbers];
            // Add a few wildcard tiles to the deck
            for (let i = 0; i < Math.floor(maxNumberValue * wildcardChance); i++) {
                deck.push(WILDCARD_VALUE);
            }
            shuffleArray(deck);
            playerHand = [];
            botHand = [];
            currentScroll = [];
            playerScore = 0;
            botScore = 0;
            lastNumberType = null;
            selectedHandCardIndex = -1;
            currentPlayer = 'player'; // Player always starts
            currentLinkingRule = 'proximity'; // Reset to default rule

            // Deal initial hands
            for (let i = 0; i < initialHandSize; i++) {
                if (deck.length > 0) playerHand.push(deck.shift());
                if (deck.length > 0) botHand.push(deck.shift());
            }

            // Render initial state
            renderPlayerHand();
            renderCurrentScroll();
            renderScores();
            renderTurnDisplay();
            renderCurrentRuleDisplay();
            showMessage('Game started! Player goes first. Choose your linking rule!', 'info');
        }

        /**
         * Draws a card from the deck and adds it to the specified hand.
         * @param {Array} hand The hand to add the card to (playerHand or botHand).
         * @param {string} owner 'Player' or 'Bot'.
         */
        function drawCard(hand, owner) {
            if (deck.length === 0) {
                showMessage('No more tiles in the deck!', 'error');
                return null;
            }
            const newCard = deck.shift();
            hand.push(newCard);
            if (owner === 'Player') {
                renderPlayerHand();
                if (newCard === WILDCARD_VALUE) {
                    showMessage(`You drew a WILDCARD!`, 'success');
                } else {
                    showMessage(`You drew number ${newCard}.`, 'info');
                }
            } else {
                showMessage(`Bot drew a tile.`, 'info');
            }
            return newCard;
        }

        /**
         * Selects a card in the player's hand.
         * @param {number} index The index of the card to select.
         */
        function selectHandCard(index) {
            if (currentPlayer !== 'player') {
                showMessage("It's not your turn!", 'error');
                return;
            }
            selectedHandCardIndex = index;
            renderPlayerHand(); // Re-render to apply 'selected-card' class

            if (playerHand[index] === WILDCARD_VALUE) {
                showMessage(`Selected WILDCARD. Enter a number and type to play it.`, 'info');
            } else {
                showMessage(`Selected ${playerHand[index]}. Now declare its type!`, 'info');
            }
        }

        /**
         * Discards the currently selected card from the player's hand.
         */
        function discardSelectedCard() {
            if (currentPlayer !== 'player') {
                showMessage("It's not your turn!", 'error');
                return;
            }
            if (selectedHandCardIndex === -1) {
                showMessage('No card selected to discard.', 'error');
                return;
            }
            const discardedNum = playerHand.splice(selectedHandCardIndex, 1)[0];
            selectedHandCardIndex = -1; // Deselect
            renderPlayerHand();
            showMessage(`You discarded ${discardedNum === WILDCARD_VALUE ? 'a Wildcard' : discardedNum}.`, 'info');
            endTurn(); // End player's turn after discarding
        }

        /**
         * Handles playing a selected card with a declared type for a given player.
         * @param {number} chosenNumber The number to play.
         * @param {string} declaredType 'prime' or 'composite'.
         * @param {string} player 'player' or 'bot'.
         * @param {number} handIndex If player, the index in playerHand. If bot, -1.
         * @returns {boolean} True if play was successful, false otherwise.
         */
        function handlePlayCard(chosenNumber, declaredType, player, handIndex) {
            const actualType = primeNumbers.has(chosenNumber) ? 'prime' : 'composite';
            let success = false;
            let message = '';
            let scoreChange = 0;

            // 1. Validate Declaration (only for non-wildcard plays or wildcard with explicit type)
            if (chosenNumber !== WILDCARD_VALUE && declaredType !== actualType) {
                scoreChange = -1;
                message = `Incorrect! ${chosenNumber} is ${actualType}. ${player === 'player' ? 'You' : 'Bot'} lose 1 point.`;
            } else if (chosenNumber === WILDCARD_VALUE && !declaredType) {
                 // This case should be caught by UI validation for wildcard
                 scoreChange = -1;
                 message = `Wildcard needs a declared type. ${player === 'player' ? 'You' : 'Bot'} lose 1 point.`;
            }
            else {
                // 2. Validate Chain Link Rules using the current active rule
                if (isValidChainPlay(chosenNumber, declaredType, currentLinkingRule)) {
                    success = true;
                    currentScroll.push({ number: chosenNumber, type: declaredType });
                    lastNumberType = declaredType;

                    if (declaredType === 'prime') {
                        scoreChange = 2;
                        message = `Correct! ${chosenNumber} is Prime. +2 points!`;
                    } else {
                        scoreChange = 1;
                        message = `Correct! ${chosenNumber} is Composite. +1 point!`;
                    }

                    // Check for bonus points
                    if (currentScroll.length === 5) {
                        scoreChange += 3;
                        message += ' Chain of 5 completed! +3 bonus points!';
                    } else if (currentScroll.length === 10) {
                        scoreChange += 7;
                        message += ' Magnificent! Chain of 10 completed! +7 bonus points!';
                    }
                } else {
                    scoreChange = -1;
                    message = `Chain Rule Broken: ${chosenNumber} cannot be played here with the ${currentLinkingRule} rule. ${player === 'player' ? 'You' : 'Bot'} lose 1 point.`;
                }
            }

            // Apply score change
            if (player === 'player') {
                playerScore += scoreChange;
            } else {
                botScore += scoreChange;
            }
            renderScores();

            // Remove card from hand
            if (player === 'player') {
                if (handIndex !== -1) playerHand.splice(handIndex, 1);
                selectedHandCardIndex = -1; // Deselect
                renderPlayerHand();
                // Clear wildcard input fields
                wildcardValueInput.value = '';
                wildcardTypeSelect.value = '';
            } else {
                // Bot's hand management is internal, just remove the card
                const botCardIndex = botHand.indexOf(chosenNumber === WILDCARD_VALUE ? WILDCARD_VALUE : chosenNumber); // Handle wildcard removal
                if (botCardIndex !== -1) botHand.splice(botCardIndex, 1);
            }

            showMessage(message, success ? 'success' : 'error');
            renderCurrentScroll();
            return success;
        }

        /**
         * Manages the turn progression.
         */
        function endTurn() {
            // Check for game over condition
            if (deck.length === 0 && playerHand.length === 0 && botHand.length === 0) {
                let finalMessage = `Game Over! Your final score: ${playerScore}, Bot's final score: ${botScore}. `;
                if (playerScore > botScore) {
                    finalMessage += "You win!";
                } else if (botScore > playerScore) {
                    finalMessage += "Bot wins!";
                } else {
                    finalMessage += "It's a tie!";
                }
                showMessage(finalMessage, 'info');
                drawCardBtn.disabled = true;
                declarePrimeBtn.disabled = true;
                declareCompositeBtn.disabled = true;
                discardBtn.disabled = true;
                ruleProximityBtn.disabled = true;
                ruleFactorMultipleBtn.disabled = true;
                return;
            }

            currentPlayer = currentPlayer === 'player' ? 'bot' : 'player';
            renderTurnDisplay();
            updateButtonStates();

            if (currentPlayer === 'bot') {
                setTimeout(botTurn, botTurnDelay);
            }
        }

        /**
         * Bot's turn logic.
         */
        function botTurn() {
            // 1. Bot draws a card
            drawCard(botHand, 'Bot');

            // 2. Bot tries to find the best valid card to play
            let bestPlay = {
                number: null,
                declaredType: null,
                handIndex: -1,
                scorePotential: -Infinity // Higher is better
            };

            // Try playing a regular card
            for (let i = 0; i < botHand.length; i++) {
                const card = botHand[i];
                if (card === WILDCARD_VALUE) continue; // Skip wildcards for now

                const cardType = primeNumbers.has(card) ? 'prime' : 'composite';
                if (isValidChainPlay(card, cardType, currentLinkingRule)) {
                    const potentialScore = (cardType === 'prime' ? 2 : 1);
                    if (potentialScore > bestPlay.scorePotential) {
                        bestPlay = {
                            number: card,
                            declaredType: cardType,
                            handIndex: i,
                            scorePotential: potentialScore
                        };
                    }
                }
            }

            // If no regular valid card, check if a wildcard can be used strategically
            const wildcardIndex = botHand.indexOf(WILDCARD_VALUE);
            if (bestPlay.number === null && wildcardIndex !== -1) {
                // Bot will try to play the wildcard as a number that is valid and gives max score (prime)
                let foundWildcardTarget = false;
                for (let num = maxNumberValue; num >= 2; num--) { // Iterate high to low for higher numbers
                    const type = primeNumbers.has(num) ? 'prime' : 'composite';
                    if (isValidChainPlay(num, type, currentLinkingRule)) {
                        bestPlay = {
                            number: num,
                            declaredType: type,
                            handIndex: wildcardIndex,
                            scorePotential: (type === 'prime' ? 2 : 1) // Wildcard scores based on declared type
                        };
                        foundWildcardTarget = true;
                        break; // Found a valid target for wildcard
                    }
                }
            }


            if (bestPlay.number !== null) {
                // Bot plays the card
                showMessage(`Bot plays ${bestPlay.number}...`, 'info');
                setTimeout(() => {
                    handlePlayCard(bestPlay.number, bestPlay.declaredType, 'bot', bestPlay.handIndex);
                    endTurn();
                }, botTurnDelay / 2); // Shorter delay for play action
            } else {
                // Bot cannot make a valid move, so it discards a card
                if (botHand.length > 0) {
                    const discardedCard = botHand.splice(0, 1)[0]; // Discard the first card
                    showMessage(`Bot discards a tile.`, 'info');
                } else {
                    showMessage(`Bot has no cards to play or discard.`, 'info');
                }
                endTurn();
            }
        }

        // --- Sieve Modal Functions ---

        function toggleSieve() {
            sieveModal.classList.toggle('show');
        }

        function hideRules() {
            rulesModal.classList.remove('show');
        }

        // --- Event Listeners ---
        drawCardBtn.addEventListener('click', () => {
            if (currentPlayer === 'player') {
                drawCard(playerHand, 'Player');
                endTurn(); // End player's turn after drawing
            } else {
                showMessage("It's not your turn to draw!", 'error');
            }
        });
        discardBtn.addEventListener('click', discardSelectedCard);

        declarePrimeBtn.addEventListener('click', () => {
            if (currentPlayer === 'player') {
                const chosenNumber = playerHand[selectedHandCardIndex];
                if (chosenNumber === WILDCARD_VALUE) {
                    showMessage("Please use the 'Play Wildcard' section for wildcard tiles.", "error");
                    return;
                }
                if (handlePlayCard(chosenNumber, 'prime', 'player', selectedHandCardIndex)) {
                    endTurn();
                }
            } else {
                showMessage("It's not your turn!", 'error');
            }
        });
        declareCompositeBtn.addEventListener('click', () => {
            if (currentPlayer === 'player') {
                const chosenNumber = playerHand[selectedHandCardIndex];
                if (chosenNumber === WILDCARD_VALUE) {
                    showMessage("Please use the 'Play Wildcard' section for wildcard tiles.", "error");
                    return;
                }
                if (handlePlayCard(chosenNumber, 'composite', 'player', selectedHandCardIndex)) {
                    endTurn();
                }
            } else {
                showMessage("It's not your turn!", 'error');
            }
        });

        // Wildcard specific play button
        playWildcardBtn.addEventListener('click', () => {
            if (currentPlayer !== 'player') {
                showMessage("It's not your turn!", 'error');
                return;
            }
            if (selectedHandCardIndex === -1 || playerHand[selectedHandCardIndex] !== WILDCARD_VALUE) {
                showMessage("No wildcard selected.", "error");
                return;
            }

            const declaredValue = parseInt(wildcardValueInput.value);
            const declaredType = wildcardTypeSelect.value;

            if (isNaN(declaredValue) || declaredValue < 2 || declaredValue > maxNumberValue) {
                showMessage(`Please enter a valid number between 2 and ${maxNumberValue} for the wildcard.`, "error");
                return;
            }
            if (!declaredType) {
                showMessage("Please select a type (Prime/Composite) for the wildcard.", "error");
                return;
            }

            // Validate if the declared value/type combination is valid for the chain
            if (isValidChainPlay(declaredValue, declaredType, currentLinkingRule)) {
                if (handlePlayCard(declaredValue, declaredType, 'player', selectedHandCardIndex)) {
                    endTurn();
                }
            } else {
                showMessage(`Wildcard play invalid: ${declaredValue} (${declaredType}) cannot be played here with the current rules.`, 'error');
            }
        });


        ruleProximityBtn.addEventListener('click', () => {
            if (currentPlayer === 'player') {
                currentLinkingRule = 'proximity';
                renderCurrentRuleDisplay();
                showMessage('Linking rule set to Proximity (±10).', 'info');
            } else {
                showMessage("It's not your turn to change the rule!", 'error');
            }
        });
        ruleFactorMultipleBtn.addEventListener('click', () => {
            if (currentPlayer === 'player') {
                currentLinkingRule = 'factor_multiple';
                renderCurrentRuleDisplay();
                showMessage('Linking rule set to Factor/Multiple.', 'info');
            } else {
                showMessage("It's not your turn to change the rule!", 'error');
            }
        });

        newGameBtn.addEventListener('click', initGame);
        toggleSieveBtn.addEventListener('click', toggleSieve);

        // --- Initial Setup ---
        generatePrimes(); // Pre-calculate primes
        renderSieveGrid(); // Render sieve for the modal
        initGame(); // Start the game on load
    </script>
</body>
</html>
